<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>?var:course.short Week 4 In-Class Activity: Single Table Verbs, Group-Aware Filtering – STA 9750 Submission Material</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d3cb4660bf9ab46fc552571f6bf3984b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">STA 9750 Submission Material</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>?var:course.short</strong> Week 4 In-Class Activity: Single Table Verbs, Group-Aware Filtering</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<pre class="{webr}"><code>#| echo: false
#| message: true
webr::install("httpuv", quiet=TRUE)
webr::install("gradethis", quiet=TRUE)
webr::install("tidyverse", quiet=TRUE)
webr::install("nycflights13", quiet=TRUE)

suppressPackageStartupMessages(library(tidyverse))

if(require("gradethis", quietly = TRUE)){
    message("Auto-grader initialized successfully. You can now begin exercises.")
}</code></pre>
</div>
<div class="cell" data-edit="false">
<pre class="{webr}"><code>#| edit: false
#| output: false
webr::install("gradethis", quiet = TRUE)
library(gradethis)
options(webr.exercise.checker = function(
  label, user_code, solution_code, check_code, envir_result, evaluate_result,
  envir_prep, last_value, engine, stage, ...
) {
  if (is.null(check_code)) {
    # No grading code, so just skip grading
    invisible(NULL)
  } else if (is.null(label)) {
    list(
      correct = FALSE,
      type = "warning",
      message = "All exercises must have a label."
    )
  } else if (is.null(solution_code)) {
    list(
      correct = FALSE,
      type = "warning",
      message = htmltools::tags$div(
        htmltools::tags$p("A problem occurred grading this exercise."),
        htmltools::tags$p(
          "No solution code was found. Note that grading exercises using the ",
          htmltools::tags$code("gradethis"),
          "package requires a model solution to be included in the document."
        )
      )
    )
  } else {
    gradethis::gradethis_exercise_checker(
      label = label, solution_code = solution_code, user_code = user_code,
      check_code = check_code, envir_result = envir_result,
      evaluate_result = evaluate_result, envir_prep = envir_prep,
      last_value = last_value, stage = stage, engine = engine)
  }
})</code></pre>
</div>
<section id="slides" class="level1">
<h1><a href="../../STA9750/slides/slides04.html">Slides</a></h1>
</section>
<section id="welcome" class="level1">
<h1>Welcome!</h1>
<section id="single-table-operations" class="level2">
<h2 class="anchored" data-anchor-id="single-table-operations">Single Table Operations</h2>
<p>This week, we are going to practice “single-table” (one data frame) operations using <code>dplyr</code>. In this scenario, we assume all the relevant data to a problem has been collected into a single object ready for use. We also assume that the data has been made “tidy” with clearly defined row and column structure.</p>
<p>For this set of exercises, we will use the <code>flights</code> data from the <code>nycflights13</code> package. Per the relevant help file, this data set contains on-time data for all flights that departed the three major NYC airports (EWR, LGA, JFK) in 2013.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> As usual, we begin by installing and loading the necessary packages:</p>
<div class="cell">
<pre class="{webr}"><code>if(!require("tidyverse")) install.packages("tidyverse")
if(!require("nycflights13")) install.packages("nycflights13")
library(tidyverse)
library(nycflights13)</code></pre>
</div>
<p>The <code>nycflights13</code> package provides us with the <code>flights</code> data set:</p>
<div class="cell">
<pre class="{webr}"><code>glimpse(flights)</code></pre>
</div>
<p>We see here that this is a large data set, with 336776 rows and 19 columns. This actually isn’t too big for <code>R</code> (only about 40 MB) but you might want to follow along with this analysis on your personal <code>R</code>, instead of in your browser if things start to feel sluggish.</p>
<p>In this <a href="../preassigns/pa04.html">week’s preassignment</a>, you already were introduced to the <code>select</code> and <code>filter</code> operators for column and row selection. Let’s now dig into them more and explore some more advanced operations.</p>
</section>
<section id="rs-missing-data-model---na" class="level2">
<h2 class="anchored" data-anchor-id="rs-missing-data-model---na"><code>R</code>’s Missing Data Model - <code>NA</code></h2>
<p>Let’s begin with a simple question: what is the <em>single most delayed flight</em> in our data set:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(arr_delay == max(arr_delay))</code></pre>
</div>
<p>Hmmmm…That’s odd. Certainly <em>something</em> has to be the maximum arrival delay - why did we get no rows back?</p>
<p>Let’s look at this expression more closely: firstly, what happens if we simply fix a delay amount?</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(arr_delay == 60)</code></pre>
</div>
<p>That’s fine. So perhaps the problem was in computing <code>max(arr_delay)</code>.</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; summarize(max(arr_delay))</code></pre>
</div>
<p>That’s weird - what is this <code>NA</code> object?</p>
<p><code>NA</code> is <code>R</code>’s representation of <em>missing</em> data: this is not a <code>NaN</code> object you have seen from other languages. <code>NaN</code> represents invalid arithmetic output (Not-a-Number), <em>e.g</em>,</p>
<div class="cell">
<pre class="{webr}"><code>0 / 0</code></pre>
</div>
<p><code>NA</code> is <em>statistical</em> missingness. The data exists - and is well defined - but we simply don’t know it. Like we said above, there is <em>some</em> most delayed flight, but we don’t know what it is.</p>
<p>The <code>NA</code> construct is a bit odd when you start with it - but it’s actually one of <code>R</code>‘s great strengths. Missingness matters in data analysis and <code>R</code> forces you to deal with it explicitly. The behavioral rules of <code>NA</code> are reasonably straightforward - <code>NA</code> is ’contagious’. Any calculation that takes at least one <code>NA</code> input usually has <code>NA</code> output. (This is not dissimilar to the “random in, random out” rule of functions of random variables) For example:</p>
<div class="cell">
<pre class="{webr}"><code>3 + NA</code></pre>
</div>
<div class="cell">
<pre class="{webr}"><code>NA &gt; 0</code></pre>
</div>
<div class="cell">
<pre class="{webr}"><code>NA / 4</code></pre>
</div>
<div class="cell">
<pre class="{webr}"><code>0 * NA</code></pre>
</div>
<p>That last result may be a bit surprising - isn’t anything times zero just zero?</p>
<p>That’s true in ‘real’ math, but not actually true for computer (“floating-point”) math:</p>
<div class="cell">
<pre class="{webr}"><code>0 * Inf</code></pre>
</div>
<p>Here, because <code>0 * NA</code> could be <code>0</code> or <code>NaN</code>, the answer is still unknown and hence <code>NA</code>.</p>
<p>There are some rare operations where <code>NA</code> can be “over-ruled” but they are not super common:</p>
<div class="cell">
<pre class="{webr}"><code>any(c(NA, TRUE))</code></pre>
</div>
<p>This follows because both:</p>
<div class="cell">
<pre class="{webr}"><code>any(c(TRUE, TRUE))
any(c(FALSE, TRUE))</code></pre>
</div>
<p>so the value of <code>NA</code> doesn’t actually matter here.</p>
<p>Also note that not all <code>NA</code> values are ‘the same’:</p>
<div class="cell">
<pre class="{webr}"><code>NA == NA</code></pre>
</div>
<p>Why is this the case? Well, suppose we rewrite this as:</p>
<div class="cell">
<pre class="{webr}"><code>today_temp    &lt;- NA
tomorrow_temp &lt;- NA

today_temp == tomorrow_temp</code></pre>
</div>
<p>Is today the same temperature as tomorrow? If we don’t know either temperature, we can’t say!</p>
<p>Similarly,</p>
<div class="cell">
<pre class="{webr}"><code>today_temp - tomorrow_temp</code></pre>
</div>
<section id="is.na-and-na.rm" class="level3">
<h3 class="anchored" data-anchor-id="is.na-and-na.rm"><code>is.na</code> and <code>na.rm</code></h3>
<p>While it’s certainly helpful that <code>R</code> handles <code>NA</code> values so intelligently for us, it can also be a bit annoying. Eventually we want (non-<code>NA</code>) answers!</p>
<p>We generally deal with this in one of two ways:</p>
<ul>
<li>filtering out <code>NA</code> values from our data set</li>
<li>ignoring <code>NA</code> values in our calculations.</li>
</ul>
<p>We’ve already done a bit of the latter option - ignoring <code>NA</code> values in our calculations - so let’s review it first.</p>
<p>Most base <code>R</code> functions have an <code>na.rm</code> optional argument to remove NA values. Returning to our motivating example:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; summarize(max(arr_delay, na.rm=TRUE))</code></pre>
</div>
<p>or indeed</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(arr_delay == max(arr_delay, na.rm=TRUE))</code></pre>
</div>
<p>That’s a horrendous (21+ hour) delay! But is it actually the “maximum” delay? It depends… we’ll come back to this example in a bit.</p>
<p>Not all functions, however, provide a <code>na.rm</code> argument: in those cases, it’s our responsibility to remove the <code>NA</code> values ourselves.</p>
<p>We can do this using the <code>is.na</code> function: this takes in a vector of values and finds the <code>NA</code>s:</p>
<div class="cell">
<pre class="{webr}"><code>x &lt;- c(1, 2, 3, NA, 5)
is.na(x)</code></pre>
</div>
<p>If we combine this with the <code>filter</code> operator, we now have an efficient way of removing <code>NA</code> values:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(!is.na(arr_delay))</code></pre>
</div>
<p>From here, we can get back to our analysis of the most delayed flight:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt;
    filter(arr_delay == max(arr_delay)) |&gt;
    glimpse()</code></pre>
</div>
<p>Poor folks!</p>
<p><em>Note that I’m using <code>glimpse</code> here to ensure all columns are printed.</em></p>
</section>
<section id="drop_na" class="level3">
<h3 class="anchored" data-anchor-id="drop_na"><code>drop_na</code></h3>
<p><code>dplyr</code> provides a <code>drop_na</code> function which removes <em>any</em> row that has an <code>NA</code> value in <em>any</em> column. It’s a bit of a blunt approach - do you really need remove a row in computing <code>X</code> just because it has an <code>NA</code> value in column <code>Y</code>? - but it can be useful for “quick and dirty” work. I recommend against using it without a thorough manual examination of your data first however.</p>
</section>
<section id="na-values-in-filter" class="level3">
<h3 class="anchored" data-anchor-id="na-values-in-filter"><code>NA</code> values in <code>filter</code></h3>
<p>Earlier we saw that <code>filter</code> plays funny with <code>NA</code> values. It’s worth being explicit here</p>
<div class="cell">
<pre class="{webr}"><code>tiny_example &lt;- tribble(~letter, ~value, "a", 1, "b", NA)
print(tiny_example)
tiny_example |&gt; filter(value &gt; 0)</code></pre>
</div>
<p><code>filter</code> checks for <code>TRUE</code> conditions - not for “not <code>FALSE</code>”. Because of this, checks which result in <code>NA</code> lead to dropped rows. This means that most <code>NA</code> rows are automatically discarded when you start filtering.</p>
<p>This isn’t a bad default - but it’s one you should be aware of. For instance, in our motivating example:</p>
<p>We might use the following to compute the average arrival delay:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(!is.na(arr_delay)) |&gt; summarize(mean(arr_delay))</code></pre>
</div>
<p>but this drops</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(is.na(arr_delay)) |&gt; NROW()</code></pre>
</div>
<p>flights for which we have no arrival delay information. Of these,</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(is.na(arr_delay), !is.na(arr_time)) |&gt; NROW()</code></pre>
</div>
<p>we even have an arrival time but the delay itself is missing for some reason. Is it fair to exclude these flights or should we compute the delay ourselves? For flights that are missing arrival and departure times (<em>i.e.</em>, cancelled flights), should we exclude them? Are they infinitely delayed? 24 hour delayed (assuming passengers were rebooked to the same flight on the next day)?</p>
<p>There’s no clear right-or-wrong answer to questions like this. It’s all context dependent: if you are the DOT trying to ensure good customer experience, a cancelled flight is <em>very</em> delayed; if you are instead a Boeing engineer looking to improve flight speeds, the cancelled flights simply aren’t useful to you.</p>
<p>When faced with these challenges, data scientists often give the answer “defer to subject matter experts (SMEs)”. Unfortunately, we rarely have the resources to have a qualified SME at hand to answer ever little data analytic question we may have.</p>
<p>I instead advocate for a strategy of <em>reproducible transparency</em>. Using tools like <code>quarto</code>, we can show our code and document the choices made. Then, when we share our results with an SME,</p>
</section>
</section>
<section id="boolean-operators-and-filter" class="level2">
<h2 class="anchored" data-anchor-id="boolean-operators-and-filter">Boolean Operators and <code>filter</code></h2>
<p><code>filter()</code> lets you use a logical test to extract specific rows from a data frame. To use <code>filter()</code>, pass it the data frame followed by one or more logical tests. <code>filter()</code> will return every row that passes each logical test.</p>
<p>So for example, we can use <code>filter()</code> to select every flight in flights that departed on January 1st:</p>
<div class="cell">
<pre class="{webr}"><code>library(nycflights13) # Load the flights data
filter(flights, month == 1, day == 1)</code></pre>
</div>
<p>The <code>filter</code> function is similar to the <code>WHERE</code> clause in SQL. As we will later see, it can also be used to implement the <code>HAVING</code> clause, when applied in conjunction with <code>group_by</code>.</p>
<p>Like all dplyr functions, <code>filter()</code> returns a new data frame for you to save or use. It doesn’t overwrite the old data frame. If you want to save the output of <code>filter()</code>, you’ll need to use the assignment operator, <code>&lt;-</code>.</p>
<p>Rerun the command in the code chunk below, but first arrange to save the output to an object named <code>jan1</code>.</p>
<div class="cell" data-exercise="ex_1">
<pre class="{webr}"><code>#| exercise: ex_1
filter(flights, month == 1, day == 1)</code></pre>
</div>
<div class="proof solution" data-exercise="ex_1">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell">
<pre class="{webr}"><code>jan1 &lt;- filter(flights, month == 1, day == 1)</code></pre>
</div>
</div>
<p>Good job! You can now see the results by running the name <code>jan1</code> by itself. Or you can pass <code>jan1</code> to a function that takes data frames as input.</p>
<p>Did you notice that this code used the double equal operator, <code>==</code>? <code>==</code> is one of R’s logical comparison operators. Comparison operators are key to making full use of <code>filter()</code>, so let’s take a closer look at them.</p>
<section id="logical-comparisons" class="level3">
<h3 class="anchored" data-anchor-id="logical-comparisons">Logical Comparisons</h3>
<p>R provides a suite of comparison operators that you can use to compare values: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> (not equal), and <code>==</code> (equal). Each creates a logical test. For example, is <code>pi</code> greater than three?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>pi <span class="sc">&gt;</span> <span class="dv">3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>When you place a logical test inside of <code>filter()</code>, filter applies the test to each row in the data frame and then returns the rows that pass, as a new data frame.</p>
<p>Our code above returned every row whose month value was equal to one <em>and</em> whose day value was equal to one.</p>
<section id="watch-out" class="level4">
<h4 class="anchored" data-anchor-id="watch-out">Watch out!</h4>
<p>When you start out with R, the easiest mistake to make is to test for equality with <code>=</code> instead of <code>==</code>. When this happens you’ll get an informative error:</p>
<div class="cell">
<pre class="{webr}"><code>filter(flights, month = 1)</code></pre>
</div>
<p>If you give <code>filter()</code> more than one logical test, <code>filter()</code> will combine the tests with an implied “and.” In other words, <code>filter()</code> will return only the rows that return <code>TRUE</code> for every test. You can combine tests in other ways with Boolean operators…</p>
</section>
<section id="and" class="level4">
<h4 class="anchored" data-anchor-id="and">&amp;, |, and !</h4>
<p>R uses Boolean operators to combine multiple logical comparisons into a single logical test. These include <code>&amp;</code> (<em>and</em>), <code>|</code> (<em>or</em>), <code>!</code> (<em>not</em> or <em>negation</em>), and <code>xor()</code> (<em>exclusive or</em>).</p>
<p>Both <code>|</code> and <code>xor()</code> will return <code>TRUE</code> if one or the other logical comparison returns <code>TRUE</code>. <code>xor()</code> differs from <code>|</code> in that it will return <code>FALSE</code> if both logical comparisons return TRUE. The name <em>xor</em> stands for <em>exclusive or</em>.</p>
<p>Study the diagram below to get a feel for how these operators work.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/transform-logical.png" class="img-fluid figure-img"></p>
<figcaption>In the figure above, <code>x</code> is the left-hand circle, <code>y</code> is the right-hand circle, and the shaded region show which parts each command selects.</figcaption>
</figure>
</div>
</section>
<section id="common-mistakes" class="level4">
<h4 class="anchored" data-anchor-id="common-mistakes">Common mistakes</h4>
<p>In <code>R</code>, the order of operations doesn’t work like English. You can’t write <code>filter(flights, month == 11 | 12)</code>, even though you might say “finds all flights that departed in November or December”. Be sure to write out a <em>complete</em> test on each side of a Boolean operator.</p>
<p>Here are four more tips to help you use logical tests and Boolean operators in <code>R</code>:</p>
<ol type="1">
<li>A useful short-hand for this problem is <code>x %in% y</code>. This will select every row where <code>x</code> is one of the values in <code>y</code>. We could use it to rewrite the code in the question above:</li>
</ol>
<div class="cell">
<pre class="{webr}"><code>nov_dec &lt;- filter(flights, month %in% c(11, 12))</code></pre>
</div>
<ol start="2" type="1">
<li>Sometimes you can simplify complicated subsetting by remembering De Morgan’s laws: <code>!(x &amp; y)</code> is the same as <code>!x | !y</code>, and <code>!(x | y)</code> is the same as <code>!x &amp; !y</code>. For example, if you wanted to find flights that weren’t delayed (on arrival or departure) by more than two hours, you could use either of the following two filters:</li>
</ol>
<div class="cell">
<pre class="{webr}"><code>dml1 &lt;- filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120))
dml2 &lt;- filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120)
identical(dml1, dml2)
dml1</code></pre>
</div>
<ol start="3" type="1">
<li><p>As well as <code>&amp;</code> and <code>|</code>, R also has <code>&amp;&amp;</code> and <code>||</code>. Don’t use them with <code>filter()</code>! You’ll learn when you should use them later.</p></li>
<li><p>Whenever you start using complicated, multipart expressions in <code>filter()</code>, consider making them explicit variables instead. That makes it much easier to check your work.</p></li>
</ol>
</section>
</section>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<section id="filter-statements" class="level4">
<h4 class="anchored" data-anchor-id="filter-statements">Filter Statements</h4>
<p>Using <code>filter</code> and various Boolean operators, find all flights satisfying the following conditions.</p>
<ol type="1">
<li>Had an arrival delay of two or more hours</li>
</ol>
<div class="cell" data-exercise="filter1">
<pre class="{webr}"><code>#| exercise: filter1
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter1">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter1" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter1
#| solution: true
flights |&gt; filter(arr_delay &gt; 120)</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter1" data-check="true">
<pre class="{webr}"><code>#| exercise: filter1
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="2" type="1">
<li>Flew to Houston (<code>IAH</code> or <code>HOU</code>)</li>
</ol>
<div class="cell" data-exercise="filter2">
<pre class="{webr}"><code>#| exercise: filter2
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter2">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter2" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter2
#| solution: true
flights |&gt; filter(dest %in% c("IAH", "HOU"))</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter2" data-check="true">
<pre class="{webr}"><code>#| exercise: filter2
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="3" type="1">
<li>Were operated by United (<code>UA</code>), American (<code>AA</code>), or Delta (<code>DL</code>)</li>
</ol>
<div class="cell" data-exercise="filter3">
<pre class="{webr}"><code>#| exercise: filter3
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter3">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter3" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter3
#| solution: true
flights |&gt; filter(carrier %in% c("UA", "AA", "DL"))</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter3" data-check="true">
<pre class="{webr}"><code>#| exercise: filter3
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="4" type="1">
<li>Departed in summer (June, July, or August)</li>
</ol>
<div class="cell" data-exercise="filter4">
<pre class="{webr}"><code>#| exercise: filter4
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter4">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter4" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter4
#| solution: true
flights |&gt; filter(month &gt;= 6, month &lt;= 8)</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter4" data-check="true">
<pre class="{webr}"><code>#| exercise: filter4
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="5" type="1">
<li>Arrived more than two hours late, but didn’t leave late</li>
</ol>
<div class="cell" data-exercise="filter5">
<pre class="{webr}"><code>#| exercise: filter5
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter5">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter5" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter5
#| solution: true
flights |&gt; filter(arr_delay &gt; 120, dep_delay &lt;= 0)</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter5" data-check="true">
<pre class="{webr}"><code>#| exercise: filter5
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="6" type="1">
<li>Were delayed more than an hour, but made up more than 30 minutes in flight</li>
</ol>
<div class="cell" data-exercise="filter6">
<pre class="{webr}"><code>#| exercise: filter6
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter6">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter6" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter6
#| solution: true
flights |&gt; filter(dep_delay &gt; 60, (dep_delay - arr_delay) &gt; 30)</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter6" data-check="true">
<pre class="{webr}"><code>#| exercise: filter6
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
<ol start="7" type="1">
<li>Departed between midnight and 6am (inclusive)</li>
</ol>
<div class="cell" data-exercise="filter7">
<pre class="{webr}"><code>#| exercise: filter7
flights |&gt; filter(______)</code></pre>
</div>
<div class="proof solution" data-exercise="filter7">
<p><span class="proof-title"><em>Solution</em>. </span></p>
<div class="cell" data-exercise="filter7" data-solution="true">
<pre class="{webr}"><code>#| exercise: filter7
#| solution: true
flights |&gt; filter((dep_time &lt;= 600) | (dep_time == 2400))</code></pre>
</div>
</div>
<div class="cell" data-exercise="filter7" data-check="true">
<pre class="{webr}"><code>#| exercise: filter7
#| check: true
gradethis::grade_this_code()</code></pre>
</div>
</section>
</section>
</section>
<section id="grouped-operations" class="level2">
<h2 class="anchored" data-anchor-id="grouped-operations">Grouped Operations</h2>
<p>In this <a href="../preassigns/pa04.html">week’s preassignment</a>, you also already saw the basics of the <code>group_by</code> operator for performing analyses on subgroups. The most common use of <code>group_by</code> is to modify <code>summarize</code> to perform group-wise summarization. We’ll next explore how it can be used to do group level filtering, similar to an SQL <code>HAVING</code> clause.</p>
<p>As before, let’s start by asking what is the average arrival delay (after removing <code>NA</code> values)?</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(!is.na(arr_delay)) |&gt; summarize(mean(arr_delay))</code></pre>
</div>
<p>Ok. But now suppose we want to know <em>which carrier</em> had flights that were later than average? We_could_ simply copy the value over into a new line of code:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; filter(!is.na(arr_delay)) |&gt; filter(arr_delay &gt; 6.90)</code></pre>
</div>
<p>To get carrier-wise statistics, we might try:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    filter(arr_delay &gt; 6.90) |&gt;
    group_by(carrier) |&gt;
    summarize(n = n())</code></pre>
</div>
<p>This works, but it requires us to keep the number 6.9 at hand, which is a bit inconvenient.</p>
<p>We next might be tempted to use a variable here to avoid hard-coding a specific value:</p>
<div class="cell">
<pre class="{webr}"><code>avg_delay &lt;- flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    summarize(mean_delay = mean(arr_delay)) |&gt;
    pull(mean_delay)

flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    filter(arr_delay &gt; avg_delay) |&gt;
    group_by(carrier) |&gt;
    summarize(n = n())</code></pre>
</div>
<p>This is definitely better! If our data changes, we don’t have to worry about the number 6.9 being ‘out of date’. But it’s still maybe a bit clunky: we filter our data twice for <code>NA</code> values and have to repeat ourselves.</p>
<p>Let’s try something else:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay))</code></pre>
</div>
<p>This creates a new column called mean delay. On its own, it’s not very interesting:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay)) |&gt;
    select(mean_delay, arr_delay, carrier, everything())</code></pre>
</div>
<p><em>Note the trick of using <code>everything()</code> inside a select statement to reorder columns.</em></p>
<p>The <code>mean_delay</code> column simply repeats the number 6.9 over and over. (Recall <code>R</code>’s recycling rules- we needed a long vector here, so the output of <code>mean</code> was repeated enough to fill the whole table.) But now we can work with this:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay)) |&gt;
    select(mean_delay, arr_delay, carrier, everything()) |&gt;
    filter(arr_delay &gt; mean_delay)</code></pre>
</div>
<p>and, if we want, we can get the carrier specific statistics:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay)) |&gt;
    select(mean_delay, arr_delay, carrier, everything()) |&gt;
    filter(arr_delay &gt; mean_delay) |&gt;
    group_by(carrier) |&gt;
    summarize(n = n())</code></pre>
</div>
<p>Pretty nice! And when it matters - for very large data stored on a database - a little faster to boot!</p>
<p>Before going deeper down this path, what happens if we move the <code>group_by</code> earlier in our pipeline?</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    group_by(carrier) |&gt;
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay)) |&gt;
    select(mean_delay, arr_delay, carrier, everything()) |&gt;
    filter(arr_delay &gt; mean_delay) |&gt;
    summarize(n = n())</code></pre>
</div>
<p>Definitely different! But why?</p>
<p>To see the difference, let’s compare the <code>mean_delay</code> column:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    group_by(carrier) |&gt;
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay)) |&gt;
    select(mean_delay, arr_delay, carrier, everything())</code></pre>
</div>
<p>We now see here that the <code>mean_delay</code> is computed “group-wise”, so we’re not getting flights that are delayed compared <em>to an average flight</em>; we are instead counting flights that are delayed compared <em>to an average flight on that airline</em>. Put another way, we’re holding American Airlines (AA) and Delta (DL) flights to a higher standard than Jet Blue (B6) or ExpressJet (EV).</p>
<p>As always - the question you should ask yourself is not “is this the right thing” but “when is this the right thing?”. It’s simply a different question!</p>
<p>Recall that <code>group_by</code> followed by a <code>summarize</code> removes one “layer” of grouping. If we use this <code>group_by</code> + <code>mutate</code> + <code>filter</code> construction, the result is still grouped, which can lead to weird bugs. To address this, it is sometimes easier to use the <code>.by</code> argument to <code>mutate</code> and <code>filter</code> which will modify the grouping <em>for that command only</em>.</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt; 
    mutate(mean_delay = mean(arr_delay), 
           .by=carrier) |&gt;
    select(mean_delay, arr_delay, carrier, everything())</code></pre>
</div>
<p>It’s a matter of taste.</p>
<section id="having-clause" class="level3">
<h3 class="anchored" data-anchor-id="having-clause"><code>HAVING</code> clause</h3>
<p>Recall that a SQL <code>HAVING</code> clause applies group-level filtering based on some summary statistics: this is easy enough in <code>dplyr</code>.</p>
<p>For example, suppose we want the average flight delays <em>of large airlines</em>, which we can define as those with more than 10,000 departures in our data set.</p>
<p>We can compute this in two ways: directly, computing the number of flights and average delay for each airline.</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt;
    group_by(carrier) |&gt;
    summarize(n = n(), 
              mean_delay = mean(arr_delay)) |&gt;
    filter(n &gt; 10000)</code></pre>
</div>
<p>This totally works, but now we’ve lost all the other flight-level information. An alternate approach is to compute counts group-wise and filter before averaging:</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt;
    group_by(carrier) |&gt;
    mutate(n = n()) |&gt;
    filter(n &gt; 10000) |&gt;
    summarize(mean_delay = mean(arr_delay)) </code></pre>
</div>
<p>This has the advantage of being readily adaptable to other non-summarizing questions: for instance, of the <em>delayed</em> flights of the major carrier, how many were going to Houston?</p>
<div class="cell">
<pre class="{webr}"><code>flights |&gt; 
    filter(!is.na(arr_delay)) |&gt;
    group_by(carrier) |&gt;
    mutate(n = n()) |&gt;
    filter(n &gt; 10000,
           arr_delay &gt; 0, # Could also write as separate filter()s
           dest %in% c("HOU", "IAH")) |&gt;
    summarize(n = n())</code></pre>
</div>
<p>Here, we re-used the <code>n</code> column and so the old value of <code>n</code> was quietly replaced. This is probably ok with a simple variable name like <code>n</code> (which wasn’t all that interesting) but for “raw” data columns, you probably should avoid this.</p>
<p>In class, we’ll do more exercises based on group-specific filtering, both filtering on groups and filtering within groups. See if you can answer:</p>
<ol type="1">
<li>What carrier has the lowest rate of delayed flights?</li>
<li>What carrier has the highest chance of early arrivals?</li>
<li>What carrier is most likely to “make up time in flight” after a delayed departure?</li>
<li>Which origin airport has the highest rate of delays?</li>
<li>Which month has the most flights?</li>
<li>What is the furthest flight in this data?</li>
<li>What is the shortest flight in this data?</li>
<li>Are longer flights more likely to be delayed than short ones?</li>
</ol>
<hr>
<p>The readings in this tutorial follow <a href="http://r4ds.had.co.nz/"><em>R for Data Science</em></a>, section 5.2. The exercises for <code>filter</code> were adapted from <a href="https://learnr-examples.shinyapps.io/ex-data-filter/">the official documentation</a> of the <code>learnr</code> package.</p>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The 2013 NYC version of this data has become a semi-standard teaching example, but the US <a href="http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&amp;Link=0">Bureau of Transportation Statistics</a> releases new versions of this data constantly. If you are interested in performing this type of analysis for a different set of airports or a different time period, check out the <a href="https://cran.r-project.org/web//packages//anyflights/index.html"><code>anyflights</code> package</a>. It’s very easy - but a bit slow - to get flight data from almost any US airport this way. If you want to develop your data cleaning skills, it’s a great exercise to parse the BTS website directly and compare your output with the <code>anyflights</code> package.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Ghirschhorn\.github\.io\/STA9750-2025-FALL\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>